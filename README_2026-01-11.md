# ASISTENTE-RAG-CORE (TFM) — Base de conocimiento del proyecto (RAG para GF 001/2023)

Este repositorio es la base del **Trabajo Fin de Máster (TFM)**: construcción de un **asistente RAG (Retrieval‑Augmented Generation)** orientado a trabajar con documentación de licitaciones (principalmente en español), con foco en:

- **Ingesta multiformato** (MD/CSV/JSON ya cubiertos en smoke; extensible a PDF/DOCX/HTML según evolucione el repo).
- **Chunking trazable** (IDs + metadatos) como prerrequisito de indexación, recuperación y citas.
- **Recuperación por similitud** (FAISS o equivalente).
- **Respuestas trazables**: objetivo final de responder **solo con contexto recuperado** y con **citas**.

La estrategia del repo es incremental y por capas: primero “plumbing” + reproducibilidad; después indexación real, retrieval real y evaluación.

---

## 1) Estado actual del proyecto (qué está hecho y validado)

### 1.1 CAPA A — Ingesta (cerrada con testing + evidencia reproducible)
**Qué hace CAPA A:** transforma documentos en una lista de `Chunk` con información suficiente para indexar, recuperar y citar.

**Qué está validado con tests (pytest):**
- Suite organizada por markers (ver `pytest.ini`):
  - `ingest_unit`: tests unitarios de limpieza/chunking/split.
  - `ingest_integration`: integración CAPA A (contratos, estabilidad).
  - `ingest_e2e`: smoke end‑to‑end (mini‑corpus sintético).
- Refuerzo crítico añadido antes de pasar a CAPA B:
  1) **Contrato mínimo del `Chunk`**: cada chunk debe tener campos esenciales consistentes (id, doc_type, source, section, text, etc.).
  2) **Determinismo básico de ingesta**: misma entrada + misma configuración → mismo resultado por `id` (contenido y metadatos).

### 1.2 Evidencia reproducible (smoke) ya disponible
Se genera evidencia auditable en `reports/ingest_smoke/` mediante script:
- `run_manifest.json` (acta de ejecución: entorno + commit + cfg + stats)
- `chunk_stats.json` (resumen legible)
- `chunks.jsonl` (salida auditable de chunks)

> Guía operativa completa de testing/evidencia: **README_TESTING.md**.

---

## 2) Arquitectura por capas (modelo mental para el TFM)

Un RAG es una cadena de etapas. Este repo se diseña explícitamente así:

### 2.1 CAPA A — Ingesta (Documentos → Chunks)
**Entrada:** documentos (según convención del repo, típicamente bajo `data/raw/...`).  
**Salida:** lista de `Chunk` con, como mínimo:
- `id` (único y trazable)
- `doc_type` (taxonomía del chunk/documento)
- `source` (ruta/origen del documento)
- `section` (sección lógica si aplica)
- `text` (contenido del chunk)
- `tags` / `metadatos` (enriquecimiento de trazabilidad)

**Por qué es crítica:** CAPA B y CAPA C dependen de que el contrato de CAPA A sea estable y completo.

### 2.2 CAPA B — Indexación (Chunks → Índice vectorial persistente)
**Entrada:** `Chunk[]`  
**Salida esperada:**
- embeddings (modelo y configuración reproducibles)
- índice (FAISS) persistido en disco
- mapping estable índice ↔ chunk (metadata/manifest)

**Riesgo típico a controlar:** recuperar “bien” pero **citar mal** por mapping incorrecto.

### 2.3 CAPA C — Retrieval (Query → Top‑k trazable)
**Entrada:** query  
**Salida esperada:** top‑k hits con IDs y metadatos listos para citar.

Nota: existe un smoke test de retrieval “plumbing” (estable, sin modelos reales) que puede saltarse si falta FAISS. Esto evita que CAPA C bloquee el cierre de CAPA A.

---

## 3) Estructura del repositorio (alto nivel)

- `src/`  
  Código productivo (layout tipo src).
- `tests/`  
  Suite de tests por capas (markers).
- `tools/`  
  Scripts auxiliares (p. ej. generación de evidencia).
- `reports/`  
  Artefactos generados localmente (evidencia, logs, manifests).
- `data/raw/`  
  Entrada de documentos (corpus real / datasets de trabajo).

---

## 4) Quickstart (mínimo para trabajar de forma segura)

Ejecuta siempre desde la raíz del repo.

### 4.1 Confirmar raíz del repo
    git rev-parse --show-toplevel

### 4.2 Activar entorno e instalar dependencias
Windows (PowerShell):
    .\.venv\Scripts\Activate.ps1
    pip install -r requirements.txt

macOS / Linux:
    source .venv/bin/activate
    pip install -r requirements.txt

### 4.3 Baseline: ejecutar toda la suite
    python -m pytest -q

---

## 5) Testing por capas (lo esencial)

Los markers están definidos en `pytest.ini`. Esto permite ejecutar por capa sin mezclar dependencias de etapas futuras.

### 5.1 CAPA A completa (unit + integration + e2e)
    python -m pytest -q -m "ingest_unit or ingest_integration or ingest_e2e"

### 5.2 Solo CAPA A integration (incluye contrato + determinismo)
    python -m pytest -q -m ingest_integration

### 5.3 Solo CAPA A end‑to‑end smoke
    python -m pytest -q -m ingest_e2e

### 5.4 Ver qué se ejecutaría (sin correr)
    python -m pytest -q -m ingest_integration --collect-only

#### Cómo interpretar outputs comunes
- `deselected`: tests encontrados pero no ejecutados por el filtro `-m`.
- `skipped`: el test se auto‑salta (por ejemplo `importorskip("faiss")`).
- `passed`: ejecutado y correcto.

---

## 6) Evidencia reproducible (lo que se enseña al tribunal)

### 6.1 Generar evidencia “smoke” (reproducible en cualquier máquina)
    python tools/generate_ingest_evidence.py --mode smoke

Salida esperada:
- `reports/ingest_smoke/run_manifest.json`
- `reports/ingest_smoke/chunk_stats.json`
- `reports/ingest_smoke/chunks.jsonl`

### 6.2 Lectura “auditoría”: qué significa cada artefacto

#### `run_manifest.json` (acta notarial)
Incluye típicamente:
- `mode`: smoke/full
- `python`, `platform`: entorno exacto
- `cwd`: directorio desde el que se ejecutó
- `git_head`: commit exacto que generó el resultado
- `cfg`: parámetros críticos (p. ej. chunk target/max/overlap)
- `stats`: resumen embebido (o equivalente)

Uso en defensa: permite afirmar “qué se ejecutó, con qué versión de código y bajo qué configuración”.

#### `chunk_stats.json` (resumen legible)
Incluye típicamente:
- `n_chunks`: número de chunks generados
- `by_doc_type`: distribución por tipo (sanity + cobertura multiformato)
- `length_chars`: min/mean/max (integridad y control de drift)
- `sample_ids`: ejemplos de IDs (trazabilidad rápida sin abrir el JSONL)

#### `chunks.jsonl` (salida auditable)
- Es la salida completa y revisable (útil para inspección y debugging).

---

## 7) Pack de evidencia recomendado (cierre formal de CAPA A)

Además de los artefactos de ingesta, conviene capturar evidencia de ejecución y entorno.

### 7.1 Guardar output del test run CAPA A
    python -m pytest -q -m "ingest_unit or ingest_integration or ingest_e2e" > reports/pytest_capaA_output.txt

### 7.2 Snapshot de dependencias
    pip freeze > reports/env_freeze.txt

### 7.3 Ruta del intérprete (asegura que usas .venv)
    python -c "import sys; print(sys.executable)" > reports/python_path.txt

Nota: si no ves output en consola, es normal: `>` redirige la salida al archivo.

---

## 8) Cobertura actual (qué cubrimos y qué falta)

### 8.1 Cubierto en esta fase
- CAPA A:
  - pipeline end‑to‑end en modo smoke (mini‑corpus controlado)
  - contrato mínimo del chunk (campos esenciales)
  - determinismo básico por `id`
  - evidencia reproducible con manifest + stats + jsonl
- CAPA C (plumbing smoke):
  - circuito retrieval (query → embed → FAISS → hits) con embedder determinista
  - tolerancia a ausencia de FAISS (SKIP, no rompe suite)

### 8.2 No cubierto todavía (planificado; normal en esta etapa)
- CAPA B real:
  - embeddings reales (modelo + cfg + device + normalización)
  - persistencia índice + mapping robusto índice↔chunk
- CAPA C real:
  - retrieval con embeddings reales y calidad mínima
- Evaluación:
  - gold set + métricas (Hit@k / Recall@k) + ejemplos con citas
- Respuesta final con citas:
  - formato de cita y contrato “no alucinación” (si no hay evidencia, decirlo)

---

## 9) Convenciones y buenas prácticas (para evitar retrabajo)

### 9.1 Sobre determinismo
Cuando el orden de descubrimiento de ficheros puede variar (filesystem), el determinismo se garantiza comparando por:
- `id` estable y único
- hash de `text` por `id`
- metadatos clave (`doc_type`, `source`, `section`)

### 9.2 Sobre `reports/`
`reports/` contiene evidencia generada localmente. Dos políticas válidas:
- No versionar `reports/` (lo típico) y adjuntar evidencia como anexos del TFM.
- Versionar solo artefactos pequeños (manifest/stats) y excluir outputs grandes (`chunks.jsonl` si crece).

La política elegida debe quedar explícita en README_TESTING.md para que el jurado sepa dónde mirar.

---

## 10) Roadmap inmediato (siguiente fase)

1) CAPA B — Indexación real
- elegir embedder (y fijar configuración reproducible)
- construir FAISS y persistirlo
- persistir metadata + manifest (mapping estable)
- añadir tests CAPA B: guardado/carga + mapping correcto

2) CAPA C — Retrieval real
- top‑k sobre índice real
- trazabilidad completa para citas

3) Evaluación mínima defendible
- mini gold set de preguntas
- métricas Hit@k/Recall@k
- ejemplos cualitativos con citas

---

## 11) Documentación relacionada
- `README_TESTING.md`: ejecución por capas, evidencia reproducible, troubleshooting.
- `pytest.ini`: markers por capas.
- `tools/generate_ingest_evidence.py`: generación de manifest/stats/jsonl.
- `tests/`: smoke e2e, retrieval smoke y tests reforzados de contrato + determinismo (CAPA A).

Fin del documento.
